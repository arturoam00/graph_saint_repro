    def _extract_numpy(self, nodes: np.ndarray) -> SubGraphData:
        # 1. Sort and deduplicate the nodes and compute the number of extracted nodes.
        nodes = np.sort(np.unique(nodes))
        n_nodes = nodes.size

        # 2. Get the full number of rows (nodes) in the original CSR.
        n_total = self.adj_train.indptr.size - 1

        # 3. For each row in the CSR, the number of outgoing edges is given by the diff of indptr.
        #    Create an array with the number of edges per row.
        degrees = np.diff(self.adj_train.indptr)

        # 4. Create an array "rows" that gives, for each edge stored in self.adj_train.indices,
        #    the corresponding source node.
        rows = np.repeat(np.arange(n_total), degrees)
        # 5. Also, create an array that gives the original position of each edge in the CSR.
        global_edge_idx = np.arange(self.adj_train.indices.size)

        # 6. We now want to keep only edges whose source and neighbor are both in the subgraph.
        #    (The original code checks "if neigh in orig2sg" for each neighbor.)
        #    Since 'nodes' is sorted, we can use np.in1d to test membership.
        mask = np.isin(rows, nodes) & np.isin(self.adj_train.indices, nodes)
        sel_rows = rows[mask]
        sel_neighbors = self.adj_train.indices[mask]
        sel_edge_index = global_edge_idx[mask]

        # 7. Remap the original node ids to the new subgraph indices.
        #    (This is equivalent to the orig2sg mapping in the original code.)
        new_rows = np.searchsorted(nodes, sel_rows)
        new_neighbors = np.searchsorted(nodes, sel_neighbors)

        # 8. Build the CSR indptr for the subgraph.
        #    Count how many edges appear in each new row.
        counts = np.bincount(new_rows, minlength=n_nodes)
        indptr = np.concatenate(([0], np.cumsum(counts))).astype(np.int64)

        # 9. The new CSR "indices" array is simply the remapped neighbors.
        indices = new_neighbors
        data = np.ones(indices.size)

        # 10. Make sure the number of edges is consistent.
        assert indptr[-1] == indices.size == sel_edge_index.size

        return SubGraphData(
            indptr=indptr,
            indices=indices,
            data=data,
            nodes=nodes,
            edge_index=sel_edge_index,
        )

    def _compute_norm_factors_numpy(self, val_max: float, val_nan: float):
        # ---- First operation: update norm_factors["aggr_tr"] per edge ----

        norm_factor_aggr_tr = np.zeros_like(self.norm_factors["aggr_tr"])

        indptr = self.adj_train.indptr
        # Number of nodes
        n_nodes = self.adj_train.shape[0]
        # Compute the degree of each node (number of edges per node)
        edge_counts = np.diff(indptr)  # shape: (n_nodes,)

        # For each edge in self.adj_train.indices (and in norm_factors["aggr_tr"]),
        # create an array that tells the source node for that edge.
        # For example, if node 5 has 3 edges then 5 appears three times.
        edge_source = np.repeat(np.arange(n_nodes), edge_counts)

        # The original per-edge values (before update) for aggr_tr:
        aggr_vals = self.norm_factors["aggr_tr"]

        # For each edge, we want to compute:
        #     new_val = clip(loss_tr[v] / clip(aggr_tr[edge], 1e-3, None), 0, MAX_VAL)
        # where v is the source node for that edge.
        loss_tr = self.norm_factors["loss_tr"]
        # Clip the aggr_tr values with a lower bound of 1e-3.
        denom = np.clip(aggr_vals, 1e-3, None)
        # Broadcast loss_tr for each edge (each edge gets its source's loss_tr)
        numer = loss_tr[edge_source]
        # Compute the ratio and clip it between 0 and MAX_VAL.
        new_vals = np.clip(numer / denom, 0, val_max)
        # Replace any NaNs with VAL_IF_NAN (in-place; note that np.nan_to_num returns the modified array)
        np.nan_to_num(new_vals, nan=val_nan, copy=False)

        # Assign the computed per-edge values back to norm_factors["aggr_tr"]
        norm_factor_aggr_tr[:] = new_vals

        return norm_factor_aggr_tr

